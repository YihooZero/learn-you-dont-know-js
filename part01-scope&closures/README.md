#### charpter1：作用域是什么

**演员表**

- 引擎

  从头到位负责整个JavaScript程序的编译及执行过程

- 编译器

  负责语法分析及代码生成等脏活累活

- 作用域

  负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

> LHS查询是试图找到变量的容器本身，从而可以对其赋值；RHS查询是取到其原值，得到某某某值。
>
> ```javascript
> console.log(a)
> // 其中对a的引用是一个RHS引用，因为这里没有对a赋任何值，相应的，需要查找并取得a的值，这样才能将值传递给console.log(...)
> a = 2;
> // 这里对a的引用是LHS引用，因为实际上我们不关心当前值是什么，只想为=2这个赋值操作找到一个目标
> 
> function foo(a) {
>     var b = a;
>     return a + b;
> }
> var c = foo(2);
> // 1、LHS查询(3处)
> // c = ..; a = 2(隐式变量分配); b = ..
> // 2、RHS查询(4处)
> // foo(2); ... = 2; a..; ..b
> ```
>
> 容易混淆的一个例子
>
> ```javascript
> var a = 1;
> console.log(a+b);
> var b = 1;
> // NaN
> // b会进行RHS查询, 由于变量提升的缘故，此时b对应为undefined,1+undefined，自然打印为NaN
> var a = 1;
> console.log(a+b);
> b = 1;
> // 报错: ReferenceError: b is not defined
> // 此处b会进行RHS查询，当其在当前和相关作用域都无法找到所需变量时，引擎会抛出ReferenceError错误
> ```
>
> 不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量(非严格模式下)，该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常(严格模式下)

#### charpter2：词法作用域

```javascript
var obj = {
    a: 1,
    b: 2
};
with(obj) {
    a = 2;
    b = 3;
    c = 4;
}
console.log(obj);       // { a: 2, b: 3 }
console.log(window.c);  // 4
```

**理解：** 当把`obj`传给`with`时，`with`所声明的作用域是`obj`，`obj`作用域中含有同`obj.a、obj.b`属性相同的标识符，但是没有`c`标识符，因此就行了正常的LHS标识符查找。`obj`作用域，全局作用域都没有找到标识符`c`，因此当`c=4`时，自动创建了一个全局变量（非严格模式）

**知识点：** `eval(...)`函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而`with`声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

#### charpter3：函数作用域和块作用域

- 区分函数声明和表达式

  最简单的方法是看`function`关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果`function`是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

  ```javascript
  // 代码片段1
  function foo() {
      var a = 1;
      console.log(a);
  }
  foo();
  
  // 代码片段2
  (function foo() {
      var a = 1
      console.log(a);
  })()
  // 函数被当做函数表达式来处理
  ```

- 函数声明和表达式最重要的区别是它们的名称标识符将会绑定在何处

  代码片段1中`foo`被绑定在所在作用域中，可以直接通过`foo()`来调用它。代码片段2中`foo`被绑定在函数表达式自身的函数中而不是所在作用域中。(代码片段2中的`foo`只能在函数体中被访问，外部作用域不行)

  

